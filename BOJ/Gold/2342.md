# 뀨

# 2342 Dance Dance Revolution 문제

![Image](https://github.com/user-attachments/assets/3c6f4d9d-ca29-4aab-b810-6e1fbe18e8b6)

처음에 게이머는 두 발을 중앙에 모으고 있다.→ `0 위치의 발판`

그리고 게임이 시작하면, 지시에 따라 왼쪽 또는 오른쪽 발을 움직인다. **하지만 그의 두 발이 동시에 움직이지는 않는다.**

이 게임에는 이상한 규칙이 더 있다. **두 발이 같은 지점에 있는 것이 허락되지 않는 것이다**. 
(물론 게임 시작시에는 예외이다) 만약, 한 발이 1의 위치에 있고, 다른 한 발이 3의 위치에 있을 때, 3을 연속으로 눌러야 한다면, 3의 위치에 있는 발로 반복해야 눌러야 한다는 것이다.

만약, 

1. **중앙에 있던 발이 다른 지점으로** 움직일 때, **2**의 힘을 사용하게 된다. 
2. 그리고 **다른 지점에서 인접한 지점으로 움직일 때**는 **3**의 힘을 사용하게 된다. (예를 들면 왼쪽에서 위`(2 → 1)`나 아래로`(2→3)` 이동할 때의 이야기이다.) 
3. 그리고 **반대편으로 움직일때**는 **4**의 힘을 사용하게 된다. (위쪽에서 아래쪽`(1→3)`으로, 또는 오른쪽에서 왼쪽`(4→2)`으로). 
4. 만약 **같은 지점을 한번 더 누른다면**, 그때는 **1**의 힘을 사용하게 된다.

ex: `1 → 2 → 2 → 4` 의 경우, **(0, 0) → (0, 1) → (2, 1) → (2, 1) → (2, 4)**로 이동하면, **8**의 힘을 사용함 **(minimum power use)**

### 1. **초기 호출**:

```c
solve(0, 0, 0);
```

- `idx = 0`, `left_pos = 0`, `right_pos = 0`
- 다음 발판: `steps[0] = 1`

### 2. **첫 번째 재귀 호출**:

- 왼발을 `1`로 이동:
    - 비용: `cost(0, 1) = 2`
    - 재귀 호출: `solve(1, 1, 0)`
- 오른발을 `1`로 이동:
    - 비용: `cost(0, 1) = 2`
    - 재귀 호출: `solve(1, 0, 1)`

---

### 3. **두 번째 재귀 호출** (`idx = 1`):

- 다음 발판: `steps[1] = 2`

### 경우 1: `solve(1, 1, 0)` (왼발: `1`, 오른발: `0`)

- 왼발을 `2`로 이동:
    - 비용: `cost(1, 2) = 3`
    - 재귀 호출: `solve(2, 2, 0)`
- 오른발을 `2`로 이동:
    - 비용: `cost(0, 2) = 2`
    - 재귀 호출: `solve(2, 1, 2)`

### 경우 2: `solve(1, 0, 1)` (왼발: `0`, 오른발: `1`)

- 왼발을 `2`로 이동:
    - 비용: `cost(0, 2) = 2`
    - 재귀 호출: `solve(2, 2, 1)`
- 오른발을 `2`로 이동:
    - 비용: `cost(1, 2) = 3`
    - 재귀 호출: `solve(2, 0, 2)`

### 4. **세 번째 재귀 호출** (`idx = 2`):

- 다음 발판: `steps[2] = 2`

### 경우 1: `solve(2, 2, 0)` (왼발: `2`, 오른발: `0`)

- 왼발을 `2`로 이동:
    - 비용: `cost(2, 2) = 1`
    - 재귀 호출: `solve(3, 2, 0)`
- 오른발을 `2`로 이동:
    - 비용: `cost(0, 2) = 2`
    - 재귀 호출: `solve(3, 2, 2)`

### 경우 2: `solve(2, 1, 2)` (왼발: `1`, 오른발: `2`)

- 왼발을 `2`로 이동:
    - 비용: `cost(1, 2) = 3`
    - 재귀 호출: `solve(3, 2, 2)`
- 오른발을 `2`로 이동:
    - **불가능** (오른발이 이미 `2`에 있음)

### 경우 3: `solve(2, 2, 1)` (왼발: `2`, 오른발: `1`)

- 왼발을 `2`로 이동:
    - 비용: `cost(2, 2) = 1`
    - 재귀 호출: `solve(3, 2, 1)`
- 오른발을 `2`로 이동:
    - 비용: `cost(1, 2) = 3`
    - 재귀 호출: `solve(3, 2, 2)`

### 경우 4: `solve(2, 0, 2)` (왼발: `0`, 오른발: `2`)

- 왼발을 `2`로 이동:
    - 비용: `cost(0, 2) = 2`
    - 재귀 호출: `solve(3, 2, 2)`
- 오른발을 `2`로 이동:
    - **불가능** (오른발이 이미 `2`에 있음)

---

### 5. **네 번째 재귀 호출** (`idx = 3`):

- 다음 발판: `steps[3] = 4`

### 경우 1: `solve(3, 2, 0)` (왼발: `2`, 오른발: `0`)

- 왼발을 `4`로 이동:
    - 비용: `cost(2, 4) = 4`
    - 재귀 호출: `solve(4, 4, 0)`
- 오른발을 `4`로 이동:
    - 비용: `cost(0, 4) = 2`
    - 재귀 호출: `solve(4, 2, 4)`

### 경우 2: `solve(3, 2, 2)` (왼발: `2`, 오른발: `2`)

- 왼발을 `4`로 이동:
    - 비용: `cost(2, 4) = 4`
    - 재귀 호출: `solve(4, 4, 2)`
- 오른발을 `4`로 이동:
    - 비용: `cost(2, 4) = 4`
    - 재귀 호출: `solve(4, 2, 4)`

### 경우 3: `solve(3, 2, 1)` (왼발: `2`, 오른발: `1`)

- 왼발을 `4`로 이동:
    - 비용: `cost(2, 4) = 4`
    - 재귀 호출: `solve(4, 4, 1)`
- 오른발을 `4`로 이동:
    - 비용: `cost(1, 4) = 3`
    - 재귀 호출: `solve(4, 2, 4)`

### 6. **종료 조건** (`idx = 4`):

- 모든 발판을 처리했으므로 `0`을 반환합니다.

---

### 값 업데이트 과정

1. **재귀 호출 반환값**:
    - 각 재귀 호출은 현재까지의 비용(`current_cost`)과 다음 재귀 호출의 결과를 더한 값을 반환합니다.
2. **메모이제이션**:
    - `dp[idx][left_pos][right_pos]`에 계산된 결과를 저장합니다.
    - 이후 동일한 상태(`idx`, `left_pos`, `right_pos`)가 다시 호출되면 저장된 값을 반환합니다.
3. **최소값 선택**:
    - 각 단계에서 왼발 또는 오른발을 움직인 결과 중 **최소값**을 선택합니다.
    
    ---
    
    ### 예시: `1 2 2 4 0`에 대한 최소 힘 계산
    
    1. **경로 1**:
        - 왼발: `0 → 1 → 2 → 4` (비용: `2 + 3 + 4 = 9`)
        - 오른발: `0 → 0 → 0 → 0` (비용: `0`)
        - 총 비용: `9`
    2. **경로 2**:
        - 왼발: `0 → 0 → 2 → 4` (비용: `2 + 2 + 4 = 8`)
        - 오른발: `0 → 1 → 1 → 1` (비용: `0`)
        - 총 비용: `8`
    
    최소 힘은 `8`입니다.
    

---