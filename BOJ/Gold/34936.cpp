//블록 생성- G5 - 2025.12.22
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <map>
#define ll long long
#define fastio ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
priority_queue<pair<ll,ll>> pq_fee; // 수수료 기준 max heap
priority_queue<pair<ll,ll>, vector<pair<ll,ll>>, greater<>> pq_time; // 시간 기준 min heap
map<pair<ll,ll>, int> removed; // (수수료, 시간) 쌍에 대해 제거된 개수 기록 -> lazy deletion 위해

int n;
ll t,k;
ll ans = 0;
int main(){
    fastio;
    cin>>n>>t>>k;
    while(n--){
        int a;
        cin>>a;
        if(a==1){
            ll b, c;
            cin>>b>>c;
            // time b에 fee c인 transaction 생성
            pq_fee.push({c, -b});
            pq_time.push({b,c});
        }
        else{
            ll b;
            cin>>b;
            // time b에 블록 생성

            // 1. 유효기간 지난 트랜잭션 제거
            while(not pq_time.empty() and pq_time.top().first < b-t){
                ll time = pq_time.top().first;
                ll fee = pq_time.top().second;
                pq_time.pop();
                removed[{fee,time}]++;
            }
            ll sum=0;
            int cnt=0;
            while(not pq_fee.empty() and cnt < k){ // 2. 수수료가 가장 큰 k개 선택
                ll fee = pq_fee.top().first;
                ll time = -pq_fee.top().second; // 저장할 때 음수로 저장했으므로 다시 양수로 바꿔줌
                
                if(removed[{fee,time}]>0){ // 이미 삭제 예정이면 건너뜀
                    removed[{fee,time}]--;
                    pq_fee.pop();
                    continue;
                }
                // block에 포함
                sum += fee;
                cnt++;
                pq_fee.pop();
            }
            ans+=sum;
        }
    }
    cout<<ans<<endl;
}

/*
7 3 2 -> 총 7개의 이벤트, t=3, k=2 -> t는 유효시간 , k는 한번에 블록에 포함시킬 수 있는 트랜잭션의 최대 개수
1 1 5 -> 1시에 수수료 5원인 트랜잭션 생성 -> 트랜잭션 풀 : {(1,5)}
1 2 10 -> 2시에 수수료 10원인 트랜잭션 생성 -> 트랜잭션 풀 : {(2,10),(1,5)} -> 수수료가 큰 트랜잭션부터 꺼내니까
2 3 -> 3을 기준으로 생성시간이 3 이하로 차이나는 트랜잭션 중에서(그니까 0~3사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> (2,10),(1,5) -> 총 수수료 15 출력 -> 트랜잭션 풀 : {}
1 5 7 -> 5시에 수수료 7원인 트랜잭션 생성 -> 트랜잭션 풀 : {(5,7)}
1 6 9 -> 6시에 수수료 9원인 트랜잭션 생성 -> 트랜잭션 풀 : {(6,9),(5,7)}
2 7 -> 7을 기준으로 생성시간이 3 이하로 차이나는 트랜잭션 중에서(그니까 4~7사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> (6,9),(5,7) -> 총 수수료 16 출력 -> 15+16 = 31 -> 트랜잭션 풀 : {}
2 10 -> 10을 기준으로 생성시간이 3 이하로 차이나는 트랜잭션 중에서(그니까 7~10사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> 트랜잭션 풀이 비어있으니까 포함시킬 트랜잭션이 없음 -> 총 수수료 0 출력 -> 31 + 0 = 31 -> 트랜잭션 풀 : {}

5 5 2 -> 총 5개의 이벤트, t=5, k=2 -> t는 유효시간 , k는 한번에 블록에 포함시킬 수 있는 트랜잭션의 최대 개수
1 1 10 -> 1시에 수수료 10원인 트랜잭션 생성 -> 트랜잭션 풀 : {(1,10)}
1 2 20 -> 2시에 수수료 20원인 트랜잭션 생성 -> 트랜잭션 풀 : {(2,20),(1,10)} -> 수수료가 큰 트랜잭션부터 꺼내니까
1 3 15 -> 3시에 수수료 15원인 트랜잭션 생성 -> 트랜잭션 풀 : {(2,20),(3,15),(1,10)}
2 4 -> 4를 기준으로 생성시간이 5 이하로 차이나는 트랜잭션 중에서(그니까 -1~4사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> (2,20),(3,15) -> 총 수수료 35 출력 -> 트랜잭션 풀 : {(1,10)}
2 8 -> 8를 기준으로 생성시간이 5 이하로 차이나는 트랜잭션 중에서(그니까 3~8사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> 지금 트랜잭션 풀엔 (1,10)인데 이게 3~8 사이에 생성된게 아니라서 꺼내서 블록에 포함시킬 수 없음 -> 총 수수료 0 출력 -> 35 + 0 = 35 -> 트랜잭션 풀 : {(1,10)}
따라서 35

7 4 2 -> 총 7개의 이벤트, t=4, k=2 -> t는 유효시간 , k는 한번에 블록에 포함시킬 수 있는 트랜잭션의 최대 개수
1 1 10 -> 1시에 수수료 10원인 트랜잭션 생성 -> 트랜잭션 풀 : {(1,10)}
1 2 10 -> 2시에 수수료 10원인 트랜잭션 생성 -> 수수료가 같다면 먼저 생성된 트랜잭션의 우선순위가 높음 -> 트랜잭션 풀 : {(1,10),(2,10)}
1 3 10 -> 3시에 수수료 10원인 트랜잭션 생성 -> 트랜잭션 풀 : {(1,10),(2,10),(3,10)}
1 4 10 -> 4시에 수수료 10원인 트랜잭션 생성 -> 트랜잭션 풀 : {(1,10),(2,10),(3,10),(4,10)}
2 5 -> 5를 기준으로 생성시간이 4 이하로 차이나는 트랜잭션 중에서(그니까 1~5사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> (1,10),(2,10) -> 총 수수료 20 출력 -> 트랜잭션 풀 : {(3,10),(4,10)}
2 7 -> 7를 기준으로 생성시간이 4 이하로 차이나는 트랜잭션 중에서(그니까 3~7사이 생성된 트랜잭션) 수수료가 가장 큰 2개의 트랜잭션을 블록에 포함시킴 -> (3,10),(4,10) -> 총 수수료 20 출력 -> 20 + 20 = 40 -> 트랜잭션 풀 : {}
1 8 5 -> 8시에 수수료 5원인 트랜잭션 생성 -> 트랜잭션 풀 : {(8,5)}
따라서 40
*/